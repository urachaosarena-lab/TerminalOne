const { Markup } = require('telegraf');

const handleWalletMenu = async (ctx) => {
  const walletService = ctx.services?.wallet;
  const userId = ctx.from.id;

  try {
    const balanceInfo = await walletService.getWalletBalance(userId);
    
    if (!balanceInfo.hasWallet) {
      await ctx.editMessageText(
        '${getBotTitle()}\n\n‚ùå No wallet found. Please create or import a wallet first.',
        {
          parse_mode: 'Markdown',
          ...Markup.inlineKeyboard([
            [Markup.button.callback('üÜï Create Wallet', 'create_wallet')],
            [Markup.button.callback('üì• Import Wallet', 'import_wallet')],
            [Markup.button.callback('üîô Back', 'back_to_main')]
          ])
        }
      );
      return;
    }

    const walletMessage = `
${getBotTitle()}

üü† **Wallet Management**

üí∞ **Balance:** ${balanceInfo.balance.toFixed(4)} SOL
üìç **Address:** \`${balanceInfo.publicKey.slice(0,5)}...${balanceInfo.publicKey.slice(-5)}\`

üîê **Manage your wallet securely**
    `;

    // Check if devnet for airdrop option
    const config = require('../../config/config');
    const isDevnet = config.solana.network === 'devnet';
    
    const buttons = [
      [Markup.button.callback('üîë View Private Key', 'view_private_key')],
      [Markup.button.callback('üìã Copy Address', 'copy_address')],
      [Markup.button.callback('üîÑ Refresh Balance', 'refresh_balance')]
    ];
    
    if (isDevnet) {
      buttons.push([Markup.button.callback('üí∞ Request SOL (Devnet)', 'request_airdrop')]);
    }
    
    buttons.push(
      [Markup.button.callback('üö™ Log Off Wallet', 'delete_wallet')],
      [Markup.button.callback('üîô Back', 'back_to_main')]
    );

    await ctx.editMessageText(walletMessage, {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard(buttons)
    });

  } catch (error) {
    console.error('Error in wallet menu:', error);
    await ctx.reply('‚ùå Error loading wallet information. Please try again.');
  }
};

const handleCreateWallet = async (ctx) => {
  const walletService = ctx.services?.wallet;
  const userId = ctx.from.id;

  try {
    // Show creating message
    await ctx.editMessageText(
      '${getBotTitle()}\n\nüîÑ **Creating your new wallet...**\n\n‚è≥ Please wait...',
      { parse_mode: 'Markdown' }
    );

    // Create wallet
    const result = await walletService.createWallet(userId);
    
    if (result.success) {
      const successMessage = `
${getBotTitle()}

üéâ **Wallet Created Successfully!**

üü¢ **Your new wallet is ready:**
üìç **Address:** \`${result.publicKey.slice(0,5)}...${result.publicKey.slice(-5)}\`

‚ö†Ô∏è **IMPORTANT SECURITY NOTICE:**
‚Ä¢ Your private key is stored securely
‚Ä¢ Always backup your wallet
‚Ä¢ Never share your private key
‚Ä¢ You are responsible for your funds

üí∞ **Your wallet balance:** 0.0000 SOL
üí° **Tip:** Fund your wallet to start trading!
      `;

      await ctx.editMessageText(successMessage, {
        parse_mode: 'Markdown',
        ...Markup.inlineKeyboard([
          [Markup.button.callback('üîë View Private Key', 'view_private_key')],
          [Markup.button.callback('üìã Copy Address', 'copy_address')],
          [Markup.button.callback('üîô Main Menu', 'back_to_main')]
        ])
      });
    }

  } catch (error) {
    console.error('Error creating wallet:', error);
    await ctx.editMessageText(
      '${getBotTitle()}\n\n‚ùå **Failed to create wallet**\n\nPlease try again later.',
      {
        parse_mode: 'Markdown',
        ...Markup.inlineKeyboard([
          [Markup.button.callback('üîÑ Try Again', 'create_wallet')],
          [Markup.button.callback('üîô Back', 'back_to_main')]
        ])
      }
    );
  }
};

const handleImportWallet = async (ctx) => {
  await ctx.editMessageText(
    '${getBotTitle()}\n\nüì• **Import Existing Wallet**\n\nüîê Send your wallet credentials in the next message\n\n**‚úÖ Supported formats:**\nüå± **Seed Phrase:** 12 or 24 words\nüîë **Private Key:** Base64 encoded\nüìã **Private Key:** JSON array [1,2,3...]\n\n**üí° Examples:**\n‚Ä¢ `word1 word2 word3 ... word12`\n‚Ä¢ `lGJkS4wqjmGGol6ZOFQb7luG...`\n‚Ä¢ `[123,45,67,89,12...]`\n\n‚ö†Ô∏è **Security:** All data encrypted & this message auto-deleted',
    {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå Cancel', 'back_to_main')]
      ])
    }
  );

  // Set user state for next message
  ctx.session = ctx.session || {};
  ctx.session.awaitingPrivateKey = true;
};

const handleViewPrivateKey = async (ctx) => {
  const walletService = ctx.services?.wallet;
  const userId = ctx.from.id;

  try {
    const wallet = walletService.getPrivateKey(userId);
    
    const keyMessage = `
${getBotTitle()}

üîê **PRIVATE KEY - KEEP SECURE!**

‚ö†Ô∏è **WARNING:** Never share this information!

**Private Key (Base64):**
\`${wallet.privateKey}\`

**Public Address:**
\`${wallet.publicKey}\`

${wallet.mnemonic ? `**Mnemonic Phrase:**\n\`${wallet.mnemonic}\`\n\nüí° Store this phrase safely - it can recover your wallet!` : 'üîÑ *Imported wallet - no mnemonic available*'}

üóëÔ∏è **This message will auto-delete in 60 seconds**
    `;

    // Send as a new message that will be deleted
    const sentMessage = await ctx.reply(keyMessage, {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('‚ùå Delete Now', 'delete_key_message')]
      ])
    });

    // Auto-delete after 60 seconds
    setTimeout(async () => {
      try {
        await ctx.deleteMessage(sentMessage.message_id);
      } catch (error) {
        // Message might already be deleted
      }
    }, 60000);

  } catch (error) {
    console.error('Error viewing private key:', error);
    await ctx.reply('‚ùå Error retrieving private key. Please try again.');
  }
};

const handleCopyAddress = async (ctx) => {
  const walletService = ctx.services?.wallet;
  const userId = ctx.from.id;

  try {
    const wallet = walletService.getUserWallet(userId);
    if (!wallet) {
      await ctx.answerCbQuery('‚ùå No wallet found');
      return;
    }

    // Show full address for easy copying
    const copyMessage = `
üìã **Your Wallet Address:**

\`${wallet.publicKey}\`

üí° **How to copy:**
‚Ä¢ On mobile: Long press the address above
‚Ä¢ On desktop: Click and drag to select
‚Ä¢ The full address will be copied to clipboard

üîí This is your **public** address - safe to share
    `;

    await ctx.reply(copyMessage, {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('üîô Back to Wallet', 'wallet')]
      ])
    });

    await ctx.answerCbQuery('üìã Full address shown above - tap to copy!');

  } catch (error) {
    console.error('Error copying address:', error);
    await ctx.answerCbQuery('‚ùå Error retrieving address');
  }
};

const handleDeleteWallet = async (ctx) => {
  await ctx.editMessageText(
    '${getBotTitle()}\n\nüö™ **LOG OFF WALLET**\n\n‚ö†Ô∏è **This will disconnect your current wallet**\n\n‚Ä¢ Your wallet will be removed from this device\n‚Ä¢ Your funds remain safe in your wallet\n‚Ä¢ You can reconnect anytime with your seed phrase\n‚Ä¢ Make sure you have your seed phrase saved!\n\n**Ready to log off?**',
    {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('üö™ Yes, Log Off', 'confirm_delete_wallet')],
        [Markup.button.callback('‚ùå Cancel', 'wallet')]
      ])
    }
  );
};

const handleConfirmDeleteWallet = async (ctx) => {
  const walletService = ctx.services?.wallet;
  const userId = ctx.from.id;

  try {
    const deleted = walletService.deleteWallet(userId);
    
    if (deleted) {
      await ctx.editMessageText(
        '${getBotTitle()}\n\n‚úÖ **Wallet Logged Off Successfully**\n\nüö™ Your wallet has been disconnected from this device.\n\nüîí **Your funds are still safe in your wallet!**\nüí° You can reconnect anytime or use a different wallet.',
        {
          parse_mode: 'Markdown',
          ...Markup.inlineKeyboard([
            [Markup.button.callback('üÜï Create New Wallet', 'create_wallet')],
            [Markup.button.callback('üì• Import Wallet', 'import_wallet')],
            [Markup.button.callback('üîô Main Menu', 'back_to_main')]
          ])
        }
      );
    } else {
      await ctx.answerCbQuery('‚ùå No wallet found to delete');
    }

  } catch (error) {
    console.error('Error deleting wallet:', error);
    await ctx.answerCbQuery('‚ùå Error deleting wallet');
  }
};

/**
 * Handle SOL airdrop request (devnet only)
 */
const handleRequestAirdrop = async (ctx) => {
  const walletService = ctx.services?.wallet;
  const userId = ctx.from.id;

  try {
    const wallet = walletService.getUserWallet(userId);
    if (!wallet) {
      await ctx.answerCbQuery('‚ùå No wallet found');
      return;
    }

    const message = `
${getBotTitle()}

üí∞ **Request Devnet SOL**

üìç **Wallet:** \`${wallet.publicKey.slice(0,5)}...${wallet.publicKey.slice(-5)}\`

üîß **Devnet Testing Only**
These are test tokens with no real value.

üíµ **How much SOL do you need?**
    `;

    await ctx.editMessageText(message, {
      parse_mode: 'Markdown',
      ...Markup.inlineKeyboard([
        [Markup.button.callback('üí∞ 1 SOL', 'airdrop_1')],
        [Markup.button.callback('üí∞ 2 SOL', 'airdrop_2')],
        [Markup.button.callback('üí∞ 5 SOL', 'airdrop_5')],
        [Markup.button.callback('‚ùå Cancel', 'wallet')]
      ])
    });

  } catch (error) {
    console.error('Error in airdrop request:', error);
    await ctx.answerCbQuery('‚ùå Error preparing airdrop request');
  }
};

/**
 * Execute airdrop
 */
const handleExecuteAirdrop = async (ctx, amount) => {
  const walletService = ctx.services?.wallet;
  const userId = ctx.from.id;

  try {
    const wallet = walletService.getUserWallet(userId);
    if (!wallet) {
      await ctx.answerCbQuery('‚ùå No wallet found');
      return;
    }

    // Show processing message
    await ctx.editMessageText(
      `${getBotTitle()}\n\nüí∞ **Requesting ${amount} SOL...**\n\n‚è≥ Please wait...`,
      { parse_mode: 'Markdown' }
    );

    // Create airdrop service
    const AirdropService = require('../services/AirdropService');
    const airdropService = new AirdropService(ctx.services.solana);

    // Request airdrop
    const result = await airdropService.requestAirdrop(wallet.publicKey, amount);

    if (result.success) {
      const successMessage = `
${getBotTitle()}

‚úÖ **Airdrop Successful!**

üí∞ **Received:** ${result.amount} SOL
üíµ **New Balance:** ${result.newBalance.toFixed(4)} SOL
üìù **Transaction:** \`${result.signature.slice(0,8)}...\`

üéâ **Ready to test strategies!**
      `;

      await ctx.editMessageText(successMessage, {
        parse_mode: 'Markdown',
        ...Markup.inlineKeyboard([
          [Markup.button.callback('üí∞ View Wallet', 'wallet')],
          [Markup.button.callback('ü§ñ Start Trading', 'martingale_menu')],
          [Markup.button.callback('üîô Main Menu', 'back_to_main')]
        ])
      });
    }

  } catch (error) {
    console.error('Airdrop execution error:', error);
    
    await ctx.editMessageText(
      `${getBotTitle()}\n\n‚ùå **Airdrop Failed**\n\n${error.message}`,
      {
        parse_mode: 'Markdown',
        ...Markup.inlineKeyboard([
          [Markup.button.callback('üîÑ Try Again', 'request_airdrop')],
          [Markup.button.callback('üîô Back', 'wallet')]
        ])
      }
    );
  }
};

module.exports = {
  handleWalletMenu,
  handleCreateWallet,
  handleImportWallet,
  handleViewPrivateKey,
  handleCopyAddress,
  handleDeleteWallet,
  handleConfirmDeleteWallet,
  handleRequestAirdrop,
  handleExecuteAirdrop
};
